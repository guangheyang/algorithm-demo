# 数据结构和算法关系？

可以容纳数据的结构成为数据结构。

算法是用来对数据结构进行处理的方法。

数据结构是静态的。

算法是动态的。

# 一维数据结构（线性数据结构）

线性的数据结构强调存储与顺序。

## 数组

### 数组定长

底层的数组长度是固定的，`js`中的数组感觉上是不固定的，原因是`js`引擎在超出长度后，在新的连续的存储空间进行扩容操作，但扩容是消耗性能的。

### 数组特性与优缺点

1. 存储在物理空间上是连续的。
2. 底层的数组长度是不可变的。
3. 数组的变量，指向了数组第一个元素的位置。arr[1],方括号表示存储地址的偏移。通过偏移查询数据性能最好。

优点：查询性能好。

缺点：

1. 因为空间必须是连续的，所以如果数组比较大，空间碎片较多，容易存不下。
2. 因为数组的长度是固定的，所以数组的内容难以被添加和删除。

### 空间碎片

声明变量时，系统连续生成存储地址，当一些变量使用后被收回，这些空间成为空间碎片。系统整理空间碎片非常缓慢，消耗性能。

## 链表

传递一个链表，必须传递链表的根节点，每个节点都认为自己是根节点。

### 链表特性与优缺点

1. 空间上不是连续的。
2. 每存放一个值，都要多开销一个引用空间。

优点：

1. 只要存储足够大，不用担心空间碎片的问题。
2. 链表的添加和删除非常容易。

缺点：

1. 查询速度慢（值查询某一位置）
2. 链表每一个节点都需创建一个指向next的引用，浪费一些空间。当节点内数据越多，这部分开销对内存影响越少。

## 遍历

将一个集合中的每一个元素进行获取并查看。

## 二维数据结构

### 二维数据结构（图）

### 树形结构

有向无环图，树形结构有一个根节点，没有回路。

叶子节点：下边没有其他节点；

节点：既不是根节点，也不是叶子节点的普通节点。

树的度：这棵树有最多叉的节点，有多少个叉这棵树的度就是多少。

树的深度：树最深有几层，树的深度就是几。

### 二叉树

树的度最多为两个的属性结构。

子节点：某个节点下面的节点。

父节点：上级节点。

#### 满二叉树

1. 所有的叶子节点都在最底层
2. 每个节点都有两个子节点

#### 完全二叉树

国内定义：

1. 叶子节点都在最后一层或倒数第二层
2. 叶子节点都向左聚拢

国际定义：

1. 叶子节点都在最后一层或倒数第二层
2. 如果有叶子节点，就必须要两个叶子节点

#### 子树

二叉树中，每一个节点或叶子节点，都是一颗子树的根节点。

在二叉树中，每个节点都认为自己是根节点。

左子树、右子树。

#### 二叉树的遍历

传递二叉树要传根节点。

1. 前序遍历（先根次序遍历）

   先打印当前的，再打印左边的子树，再打印右边的子树

2. 中序遍历（中根次序遍历）当节点少时可以理解为对于这个二叉树的投影

   先打印左边的子树，再打印当前的，再打v印右边的子树

3. 后序遍历（后根次序遍历）

   先打印左边的子树，再打印右边的子树，再打印当前的

#### 二叉树的搜索

深度优先搜索：更适合探索未知

广度优先搜索：更适合探索局域

对于二叉树来说，深度优先搜索和前序遍历的顺序一致。

### 图的最小生成树

普利姆算法（加点法）：

1. 任选一个点为起点
2. 找到以当前选中的起点路径最短的边
3. 如果这个边的另一端没有被联通进来，那么就连接
4. 如果这个边的另一端早就连进来了，则看倒数第二短的边
5. 重复2~4直到将所有点都连通

克鲁斯卡尔算法（加边法）：

1. 选择最短的边进行连接
2. 要保证边连接的两端至少有一个点是新的点
3. 或者这个边是将两个部落进行连接的
4. 重复1~3直到将所有点都连通

### 二叉搜索树（二叉排序树）

首先这是一棵二叉树，其次有排序的效果，左子树的节点都比当前节点小，右子树的节点都比当前节点大

### 平衡二叉树

1. 根节点的左子树与右子树的高度差不能超过1
2. 这棵二叉树的每个子树都符合第一条