# 数据结构和算法关系？

可以容纳数据的结构成为数据结构。

算法是用来对数据结构进行处理的方法。

数据结构是静态的。

算法是动态的。

# 一维数据结构（线性数据结构）

线性的数据结构强调存储与顺序。

## 数组

### 数组定长

底层的数组长度是固定的，`js`中的数组感觉上是不固定的，原因是`js`引擎在超出长度后，在新的连续的存储空间进行扩容操作，但扩容是消耗性能的。

### 数组特性与优缺点

1. 存储在物理空间上是连续的。
2. 底层的数组长度是不可变的。
3. 数组的变量，指向了数组第一个元素的位置。arr[1],方括号表示存储地址的偏移。通过偏移查询数据性能最好。

优点：查询性能好。

缺点：

1. 因为空间必须是连续的，所以如果数组比较大，空间碎片较多，容易存不下。
2. 因为数组的长度是固定的，所以数组的内容难以被添加和删除。

### 空间碎片

声明变量时，系统连续生成存储地址，当一些变量使用后被收回，这些空间成为空间碎片。系统整理空间碎片非常缓慢，消耗性能。

## 链表

传递一个链表，必须传递链表的根节点，每个节点都认为自己是根节点。

### 链表特性与优缺点

1. 空间上不是连续的。
2. 每存放一个值，都要多开销一个引用空间。

优点：

1. 只要存储足够大，不用担心空间碎片的问题。
2. 链表的添加和删除非常容易。

缺点：

1. 查询速度慢（值查询某一位置）
2. 链表每一个节点都需创建一个指向next的引用，浪费一些空间。当节点内数据越多，这部分开销对内存影响越少。

## 遍历

将一个集合中的每一个元素进行获取并查看。

## 二维数据结构

### 二维数据结构（图）

### 树形结构

有向无环图，树形结构有一个根节点，没有回路。

叶子节点：下边没有其他节点；

节点：既不是根节点，也不是叶子节点的普通节点。

树的度：这棵树有最多叉的节点，有多少个叉这棵树的度就是多少。

树的深度：树最深有几层，树的深度就是几。

### 二叉树

树的度最多为两个的属性结构。

子节点：某个节点下面的节点。

父节点：上级节点。

#### 满二叉树

1. 所有的叶子节点都在最底层
2. 每个节点都有两个子节点

#### 完全二叉树

国内定义：

1. 叶子节点都在最后一层或倒数第二层
2. 叶子节点都向左聚拢

国际定义：

1. 叶子节点都在最后一层或倒数第二层
2. 如果有叶子节点，就必须要两个叶子节点

#### 子树

二叉树中，每一个节点或叶子节点，都是一颗子树的根节点。

在二叉树中，每个节点都认为自己是根节点。

左子树、右子树。

#### 二叉树的遍历

传递二叉树要传根节点。

1. 前序遍历（先根次序遍历）

   先打印当前的，再打印左边的子树，再打印右边的子树

2. 中序遍历（中根次序遍历）当节点少时可以理解为对于这个二叉树的投影

   先打印左边的子树，再打印当前的，再打v印右边的子树

3. 后序遍历（后根次序遍历）

   先打印左边的子树，再打印右边的子树，再打印当前的

#### 二叉树的搜索

深度优先搜索：更适合探索未知

广度优先搜索：更适合探索局域

对于二叉树来说，深度优先搜索和前序遍历的顺序一致。

### 图的最小生成树

普利姆算法（加点法）：

1. 任选一个点为起点
2. 找到以当前选中的起点路径最短的边
3. 如果这个边的另一端没有被联通进来，那么就连接
4. 如果这个边的另一端早就连进来了，则看倒数第二短的边
5. 重复2~4直到将所有点都连通

克鲁斯卡尔算法（加边法）：

1. 选择最短的边进行连接
2. 要保证边连接的两端至少有一个点是新的点
3. 或者这个边是将两个部落进行连接的
4. 重复1~3直到将所有点都连通

### 二叉搜索树（二叉排序树）

首先这是一棵二叉树，其次有排序的效果，左子树的节点都比当前节点小，右子树的节点都比当前节点大

### 平衡二叉树

1. 根节点的左子树与右子树的高度差不能超过1
2. 这棵二叉树的每个子树都符合第一条

### 二叉树的单旋操作（左单旋、右单旋）

某一节点不平衡，如果左边浅，右边深，进行左单旋

旋转节点：不平衡的节点为旋转节点

新根：旋转之后称为节点的节点

变化分支：父级节点发生变化的那个分支

不变分支：父级节点不变的那个分支

#### 左单旋时：

旋转节点：当前不平衡的节点

新根：右子树的根节点

变换分支：旋转结点的右子树的左子树

不变分支：旋转结点的右子树的右子树

#### 左单旋时：

旋转节点：当前不平衡的节点

新根：左子树的根节点

变换分支：旋转结点的左子树的右子树

不变分支：旋转结点的右子树的左子树

#### 进行左单旋

1. 找到新根
2. 找到变化分支
3. 当前旋转节点的右孩子为变化分支
4. 新根的左孩子为旋转节点
5. 返回新的根节点

#### 进行右单旋

1. 找到新根
2. 找到变化分支
3. 当前旋转节点的左孩子为变化分支
4. 新根的右孩子为旋转节点
5. 返回新的根节点

### 二叉树的双旋（左右双旋、右左双旋）

变化分支，不可以是唯一的最深分支，如果变化分支为最深分支，要先进行反向旋转

当对某个节点进行左单旋时，如果变化分支是唯一的最深分支，那么要对性进行右单旋，在进行左单旋，这种旋转叫做右左双旋；

当对某个节点进行右单旋时，如果变化分支是唯一的最深分支，那么要对性进行左单旋，在进行右单旋，这种旋转叫做左右双旋；

### 二叉树的双旋（左右双旋、右左双旋）

如果变化分支的高度比旋转节点的另一侧的高度度差距超过2，那么单旋之后依旧不平衡。

### 234树的由来

二叉平衡排序树性能是极致吗？不是。

如果要提升二叉平衡排序树的性能该如何做？

影响二叉平衡排序树的性能的点在哪里？

答：在于二叉平衡排序树只能有两个叉，导致在节点铺满的情况下也会有很多层，浪费了时间的性能；希望可以一个节点存储多个数，来提升空间的性能。

如何才能让查找效率尽可能高。

答：树的层级越少，查找效率越高。

怎样才能让二叉平衡排序树的层数变得更少？

答：如果不是二叉，层数会更少。

#### 234树

我们希望有一棵树，最多有四个叉（度为4）。

234树的子节点永远在最后一层，且永远是平衡的（每一个路径高度都相同）。

达成一定的效果，分支变多了，层数变少了。节点中存的数变多了，节点变少了。因为分支多了，所以复杂度上升了。所以希望能简化为二叉树，且依旧保留多叉，节点中存放多个数。

### 红黑树

性能：

1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）。
4. 从任一节点到其每个叶子节点的所有路径都包含相同的黑色节点。

